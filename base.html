<!doctype html>
<html lang="en">
<head>
	<base target="_parent" />
	<meta charset="utf-8" />
	<title>Bunny Game</title>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
	<style>
	body { background-color: #ccc; text-align: center; }
	</style>
	<script type="text/javascript" src="jquery-2.1.4.js"></script>

		
	<script type="text/javascript">
	/*
	TODOs:
	- Verwendung von CanvasToScene und SceneToCanvas (statt dauerhaft mit x & y Koordinaten auf dem Canvas)
	- statt setInterval: https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame (mehr details: https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/)
	- siehe clampElementOnCanvas()
	*/
	$(document).ready(function() {
		
		var _currentHeight = 0;
		function Vector2(_x, _y) {
				this.x = _x;
				this.y = _y;
			this.distance = function (v) {
							a = v.x-this.x;
					b = v.y-this.y;
					return Math.sqrt(a*a+b*b);
					}
		}
		
		var canvas=$("#canv");
		// var canvas = document.getElementById("canv");
		var _height = 400;
		var _width = 400;
		
		// 0, 0 is top left corner in canvas coordinates
		// it's easier if 0,0 is in bottom left and y goes up
		// also need some kind of scene coordinates for scrolling camera
		
		canvas.height(_height);
		canvas.width(_width);
		canvas[0].height=_height;
		canvas[0].width=_width;	
		var ctx = $("#canv")[0].getContext("2d");
		// lines around shapes
		ctx.strokeStyle='#00aa00';
				
		var _mousePos = new Vector2(0,0);
		var _player = new Vector2(_width/2, _height-30);
		var _dy = 0; // movement
		
		var _targets =[]; //gotta keep track of targets
		var _targetCount = 4; //how many targets should be kept track of at a time..
		var _targetHeightDifference = 60; // difference between targets
		var _currentTargetHeight = _targetHeightDifference;	// current camera height
		var _currentTargetWidth = _width/2;
		
		var _eps = 5; // epsilon
		var _points = 0; //points should count up..
		var _gravity = 0.035;

		var _gameover = false;
		/////////////
		// helpers //
		/////////////
		function aboutEquals(a,b,epsilon)
		{
			if(Math.abs(a-b)<epsilon)
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		function lerp(a,b,factor)
		{
			return a + factor *( b - a);;
		}
		function lerpPos(a,b,factor)
		{
			c[0]= lerp(a[0], b[0], factor);
			c[1]= lerp(a[1], b[1], factor);
			return new Vector2(lerp(a.x, b.x, factor),lerp(a.y, b.y, factor));
		}
		function clamp(floatA,floatMin,floatMax)
		{
			return Math.max(Math.min(floatA,floatMax),floatMin);
		}
		function clampPos(pos,floatMinX,floatMinY,floatMaxX,floatMaxY)
		{
			return new Vector2(clamp(pos.x,floatMinX,floatMaxX),clamp(pos.y,floatMinY,floatMaxY));
		}
		// TODO ggf. verwenden, sodass der Spieler oder die Targets nicht vom canvas verschwinden
		function clampElementOnCanvas(pos) {
			return new Vector2(pos, 0, _height-30, _width, 0);//letzter Parameter korrekt?! targets können ja auch außerhalb des canvas sein; werden nur nicht gemalt
		}
		function CanvasToScene(a,b)
		{
				return new Vector2(a,_height-b+_currentHeight);
		}
		function SceneToCanvas(vector)
		{
				return [vector.x,_height-(vector.y-_currentHeight)];
		}
		function randomRange(from,to)
		{
			a = Math.min(from,to);
			b = Math.max(from,to);
			return Math.floor((Math.random() * b) + a);
		}
		
		function randomSign() {
			return Math.random() < 0.5 ? -1 : 1;
		}
		
		function getMousePos(canvas, evt) {
				var rect = canvas.getBoundingClientRect();
			
				return CanvasToScene(evt.clientX - rect.left,evt.clientY - rect.top);
		}
		// end helper functions
			
		function loop()
		{
			// implement game loop here
			clearCanvas();
			checkCollision();
			drawPlayer();
			drawTargets();
			_player.x = _mousePos.x;
			
			_dy += _gravity;
			_player.y += _dy;
			if(_player.y > _height-30) { _player.y = _height-30; }
		}
		
		function clearCanvas() {
			// set background color
			ctx.fillStyle = '#cc4422';
			ctx.fillRect(0, 0, _height, _width);
		}
		
		function checkCollision() {
			var player = new Vector2(_player.x, _player.y);
			_targets.forEach(function(trg) {
				if(aboutEquals(player.x, trg.x, _eps*2) && aboutEquals(player.y, trg.y, _eps*2)) {
					_dy = -3;
					destroyTarget(trg);
				}
			});
		}
		
		function destroyTarget(target) {
			var index = _targets.indexOf(target);
			if(index > -1) {
				_targets.splice(index,1);
			}
		}
		
		function drawPlayer() {
			ctx.beginPath();
			ctx.arc(_player.x, _player.y, 10, 0, Math.PI*2);
			ctx.fillStyle = "#dd9500";
			ctx.fill();
			ctx.closePath();
		}
		
		function drawTargets() {
			if(_targets.length < _targetCount) {
				_currentTargetWidth += randomRange(30, 80) * randomSign();
				if(_currentTargetWidth < 0) _currentTargetWidth = 0;
				else if(_currentTargetWidth > _width) _currentTargetWidth = _width;
				_targets.push(new Vector2(_currentTargetWidth, _currentTargetHeight));
				_currentTargetHeight -= _targetHeightDifference;
			}
			
			_targets.forEach(function(trg) {
				drawTarget(trg);
			});
		}
		
		function drawTarget(position) {
			ctx.beginPath();
			ctx.arc(position.x, position.y, 10, 0, Math.PI*2);
			ctx.fillStyle = "#dddd00";
			ctx.fill();
			ctx.closePath();
		}
		
		function setup()
		{
		_currentTargetHeight = 300;
			
			// input
			canvas[0].addEventListener('mousemove', function(evt) {
				//mouse move logic
				_mousePos = getMousePos(document.getElementById('canv'), evt);
			}, false);
			canvas[0].addEventListener('mousedown', function(evt) {
				//jump logic
				if(/*_currentHeight*/ _player.y >= _height-30 && _points == 0) {
					_dy = -3;
				}
			}, false);
		}
		setup();
		setInterval(loop, 10);//makes the loop happen
	});
	
	
	</script>
</head>
<body>
<canvas id="canv" width="400" height="400"></canvas>
</body>
</html>
